## 5.2 KMP

KMP应用于模式串匹配问题，在给定的字符串$S$中寻找字符串$T$出现的位置。容易观察到，在暴力匹配失配时往往有更好的跳转的位置，满足前缀与后缀若干长度相等。

约定下标从0开始，那么我们可以预先求得数组$nxt$，$nxt[i]$表示字串$T[0, i - 1]$的最长的前缀等于后缀的长度，即$T[0, nxt[i] - 1] == T[i - nxt[i], i - 1]$。

那么在匹配时如果发生失配$S[i]!=T[k]$，那么则有$S[.., i - 1] = T[0, k - 1]$，根据$nxt[i]$的定义，可知$T[0, nxt[k] - 1] = T[.., k - 1] == S[.., i - 1]$，且根据$nxt[]$定义不会有更长的匹配，那么可以令$k = nxt[k]$继续匹配。

```c++
cin >> S >> T;
int len1 = strlen(S), len2 = strlen(T);
for (int k = 0, i = 1; i < len2; i++) {
    while(k && T[i] != T[k]) k = nxt[k];
    nxt[i + 1] = T[i] == T[k] ? ++k : 0;
}
for (int k = 0, i = 0; i < len1; i++) {
    while(k && S[i] != T[k]) k = nxt[k];
    if (S[i] == T[k]) k++;
    if (k == len2)
        cout << i + 2 - len2 << endl;
}
```

### P4391 \[BOI2009\]Radio Transmission 无线传输

一个很经典的trick，给定由串$T$自我连接形成的串$S$，求$T$的最短长度，答案其实就是$n - nxt[n]$。

即如果一个串一定是具有循环节的话，那么无论循环节是否完整，中间大段重复的循环节都可以构成最长的公共前后缀，循环节的长度就是$n - nxt[n]$。

### P3426 \[POI2005\]SZA-Template

定义可重叠连接指合并完全相同的部分后拼接，如$aba$经过可重叠连接得到$ababa$。给定串$T$是由$S$可重叠的连接形成的，求$S$的最小长度。

可知答案串一定是$T$的公共前后缀，或者是串$T$本身，简单的思路是通过kmp暴力匹配所有公共前后缀，但是时间代价是$O(n^{2})$。

考虑dp，$f[i]$表示长度为$i$的前缀的子问题的答案，那么我们考虑转移方程。不考虑串本身的情况下，可能的答案只能是公共前后缀，而由于其性质可知，可能的答案集合一定满足$ans(nxt[i]) \in ans(i)$，其中差的刚好就是$T[0, nxt[i] - 1]$，那么$f[i]$与$f[nxt[i]]$存在怎样的关系呢？

考虑对暴力的优化，如果已知$f[nxt[i]]$了，那么只会有两种情况：$f[i] = f[nxt[i]]$或者$f[i] = i$。为什么这里不需要考虑其他的公共前后缀了呢？因为$f[nxt[i]]$说明子串$T[0, f[nxt[i]] - 1]$一定能通过重叠连接得到其他更长的公共前后缀（这里证明其实不是很充分，是一个感性结论），而根据定义也不需要考虑更短的，因此只有这两种情况。

考虑什么条件下$f[i] = f[nxt[i]]$，那么就是存在$j$，满足$f[j] = f[nxt[i]], j + nxt[i] >= i$，否则$f[i] = i$，线性递推即可。